import os
import sys
from datetime import datetime

LNK_MAGIC = '4c000000'
LNK_GUID = '0114020000000000c000000000000046'
FLAGS = {
    0: {
        0: 'No shell id list',
        1: 'Shell item id'
    },
    1: {
        0: 'Points to something else',
        1: 'Points to a file/directory'
    },
    2: {
        0: 'No description string',
        1: 'Has a description string'
    },
    3: {
        0: 'No relative path',
        1: 'Has a relative path string'
    },
    4: {
        0: 'No working directory',
        1: 'Has a working directory'
    },
    5: {
        0: 'No command line arguments',
        1: 'Has command line argument'
    },
    6: {
        0: 'Default icon',
        1: 'Custom icon'
    }
}

SHOWWND = {
    0: 'SW_HIDE',
    1: 'SW_NORMAL',
    2: 'SW_SHOWMINIMIZED',
    3: 'SW_SHOWMAXIMIZED',
    4: 'SW_SHOWNOACTIVATE',
    5: 'SW_SHOW',
    6: 'SW_MINIMIZE',
    7: 'SW_SHOWMINNOACTIVE',
    8: 'SW_SHOWNA',
    9: 'SW_RESTORE',
    10: 'SW_SHOWDEFAULT'
}

FILE_ATTRIBUTES = {
    0: 'Read only',
    1: 'Hidden',
    2: 'System file',
    3: 'Volume Label',
    4: 'Directory',
    5: 'Modified since last backup (Archive)',
    6: 'Encrypted',
    7: 'Normal',
    8: 'Temporary',
    9: 'Sparse file',
    10: 'Has reparse point data',
    11: 'Compressed',
    12: 'Offline'
}


class MSLinkParser:
    """
    References:
        https://msdn.microsoft.com/en-us/library/dd871305.aspx
        https://ithreats.files.wordpress.com/2009/05/lnk_the_windows_shortcut_file_format.pdf
    """

    def __init__(self, lnk_path):
        self.lnk_path = lnk_path
        self.binary = open(self.lnk_path, 'rb')
        self.header_flags = []

        if not self.__is_lnk():
            raise Exception("This is not a supported file")

    def __is_lnk(self):
        """
        Checks if the file is really a Microsoft Shell Link
        :return: bool
        """
        if self.__read_offset(0, 4) != LNK_MAGIC:
            return False
        if self.__read_offset(4, 16) != LNK_GUID:
            return False
        return True

    def __read_offset(self, offset, bytes_qnt=None, binary=False, string=False):
        """
        This function reads an specific offset of the file
        :param offset: offset to seek
        :param bytes_qnt: amount of bytes to read
        :param binary: if you want the result in the binary format, please, mark this flag
        :return: hex value in the offset
        """
        self.binary.seek(offset)

        if binary:
            bin_dmp = self.binary.read(bytes_qnt)
            return ''.join(['{0:08b}'.format(ord(n))[::-1] for n in bin_dmp])

        if string:
            final_str = ""
            char = self.binary.read(1)
            while char != "\x00":
                final_str += str(char)
                char = self.binary.read(1)
            return final_str
        return self.binary.read(bytes_qnt).encode('hex')

    # ------------------------------------- File Header ------------------------------------- #

    def get_file_flags(self, get_bin=False):
        """
        Get the flags of the file - 4 bytes in offset 14h - 20d
        :return: str
        """
        bin_values = self.__read_offset(20, 4, True)[:7]
        self.header_flags = [FLAGS[i][int(item)] for i, item in enumerate(bin_values)]
        return self.header_flags if not get_bin else bin_values

    def get_file_attribute(self):
        """
        Gets the file attribute - 4 bytes in offset 18h - 28d
        :return: attribute string
        """
        attr_list = []
        if FLAGS[1][0] in self.get_file_flags():
            return attr_list

        attributes = self.__read_offset(24, 4, True)
        for i, item in enumerate(attributes):
            if int(item) != 0:
                attr_list.append(FILE_ATTRIBUTES[i])
        return attr_list

    def get_creation_time(self):
        """
        Get the creation time - 8 bytes in offset 1Ch - 28d
        :return: str
        """
        return self.__convert_ms_time_to_unix(self.__read_offset(28, 8))

    def get_modification_time(self):
        """
        Get the modification time - 8 bytes in offset 24h - 36d
        :return: str
        """
        return self.__convert_ms_time_to_unix(self.__read_offset(36, 8))

    def get_last_access_time(self):
        """
        Get the last access time - 8 bytes in offset 2Ch - 44d
        :return: str
        """
        return self.__convert_ms_time_to_unix(self.__read_offset(44, 8))

    def get_file_length(self):
        """
        Gets the file length - 4 bytes in offset 34h - 52d
        :return: length in bytes
        """
        return str(int(self.__big_to_little_endian(self.__read_offset(52, 4)), 16))

    def get_icon_number(self):
        """
        Gets the Icon Number - 4 bytes in offset 38h - 56d
        :return: attribute string
        """
        if FLAGS[6][0] in self.get_file_flags():
            return None
        return int(self.__big_to_little_endian(self.__read_offset(56, 4)), 16)

    def get_show_wnd(self):
        """
        Gets the ShowWnd attribute - 4 bytes in offset 3Ch - 60d
        :return: attribute string
        """
        sw_attr = int(self.__big_to_little_endian(self.__read_offset(60, 4)), 16)
        return SHOWWND[sw_attr]

    # ------------------------------------- File Location Info -------------------------------------#

    def __read_file_loc_info(self, offset, bytes_qnt):
        """
        Returns the correct offset that are located at the file location info structure.
        For example: Base Pathname = File Location Info Offset  + (File Location Info Offset + 16)
        :param offset: offset that you need to read
        :param bytes_qnt: how many bytes
        :return: offset
        """
        file_loc_offset = self.get_file_location_offset()
        return file_loc_offset + int(
            self.__big_to_little_endian(self.__read_offset(file_loc_offset + offset, bytes_qnt)), 16)

    def get_file_location_offset(self):
        """
        Gets the file location info offset. Offset of items start (0x4e) + Size of items length
        :return: int
        """
        return 78 + int(self.__big_to_little_endian(self.__read_offset(76, 2)), 16)

    def check_volume_type(self, local=True):
        """
        This method will check if it's a local or a network volume
        :return: bool
        """
        flags_offset = self.get_file_location_offset() + 8
        flags = self.__read_offset(flags_offset, 4, True)

        # Checks if it's available on local path
        if local:
            if flags[0] != '1':
                return False
            return True
        if flags[1] != '1':
            return False
        return True

    def get_base_path(self):
        """
        Gets the base path of LNK
        :return: str
        """
        if not self.check_volume_type(True):
            return ''
        bp_off = self.__read_file_loc_info(16, 4)
        return self.__read_offset(bp_off, string=True)

    def get_network_info(self):
        """
        Gets the network information
        :return: str
        """
        if not self.check_volume_type(False):
            return ''
        net_off = self.__read_file_loc_info(20, 4)
        return self.__read_offset(net_off, string=True)

    def get_remaining_path(self):
        """
        Gets the remaining path info
        :return: str
        """
        rem_off = self.__read_file_loc_info(24, 4)
        return self.__read_offset(rem_off, string=True)

    # ------------------------------------- Remaining Info -------------------------------------#

    def __read_remaining_info(self, offset):
        """
        Reads the remaining info
        :param offset: offset of the info
        :return: str, int
        """
        info_len = 2 * int(self.__big_to_little_endian(self.__read_offset(offset, 2)), 16)
        info_hex = self.__read_offset(offset + 2, info_len)
        info_str = ''
        for i in range(0, len(info_hex), 2):
            char = info_hex[i:i + 2]
            if char == '00':
                continue
            info_str += chr(int(char, 16))
        return info_str, self.binary.tell()

    def get_remaining_info(self):
        """
        Returns an dict with the remaining info
        :return: dict with description, relative path, command line and icon path
        """
        # File Location structure length
        fl_start = self.get_file_location_offset()
        fl_length = int(self.__big_to_little_endian(self.__read_offset(fl_start, 4)), 16)
        flags = self.get_file_flags(True)
        remaining_offset = fl_start + fl_length
        remaining_info = {}

        # Description
        if flags[2] == '1':
            remaining_info['Description'], remaining_offset = self.__read_remaining_info(remaining_offset)

        # Relative Path
        if flags[3] == '1':
            remaining_info['Relative Path'], remaining_offset = self.__read_remaining_info(remaining_offset)

        # Working dir
        if flags[4] == '1':
            remaining_info['Working dir'], remaining_offset = self.__read_remaining_info(remaining_offset)

        # Command line
        if flags[5] == '1':
            remaining_info['Command line'], remaining_offset = self.__read_remaining_info(remaining_offset)

        # Icon path
        if flags[6] == '1':
            remaining_info['Icon path'], remaining_offset = self.__read_remaining_info(remaining_offset)

        return remaining_info

    # ------------------------------------- Other methods -------------------------------------#

    def __convert_ms_time_to_unix(self, hex_dmp):
        """
        Reference: https://gist.github.com/nowhereman/189111/cea221bac63a7bc819e8b459370b2439e61ac37a
        :param hex_dmp: Hex dump for the date
        :return: str
        """
        # Converts the HEX format to Little-Endian
        le_format = self.__big_to_little_endian(hex_dmp)
        return str(datetime.fromtimestamp((int(le_format, 16) / 10000000.0 - 11644473600)))

    @staticmethod
    def __big_to_little_endian(hex_dmp):
        """
        This function will convert an Big-Endian hex format to Little-Endian
        :param hex_dmp: hex value to convert
        :return: str
        """
        return ''.join([hex_dmp[i:i + 2] for i in range(0, len(hex_dmp), 2)][::-1])

    # ------------------------------------- Print Information -------------------------------------#

    def print_lnk_header(self):
        """
        This method will print all information about the LNK file Header
        :return: str
        """
        print(" -------- Header -------- ")
        print("Original file name: {}".format(os.path.basename(self.lnk_path)))
        print("Flags: {}".format(self.get_file_flags()))
        print("Attributes: {}".format(self.get_file_attribute()))
        print("Created at: {}".format(self.get_creation_time()))
        print("Last modified at: {}".format(self.get_modification_time()))
        print("Last access at: {}".format(self.get_last_access_time()))
        print("File length: {} bytes".format(self.get_file_length()))
        print("Icon number: {}".format(self.get_icon_number()))
        print("ShowWnd: {}".format(self.get_show_wnd()))

    def print_file_location_info(self):
        """
        This method will print all information about the offsets in file location info
        :return: str
        """
        print('\n -------- File location info --------')
        print('Base path: {}'.format(self.get_base_path()))
        print('Network path: {}'.format(self.get_network_info()))
        print('Remaining path: {}'.format(self.get_remaining_path()))
        remaining_info = self.get_remaining_info()
        for item in remaining_info:
            print('{}: {}'.format(item, remaining_info[item]))

    def print_lnk_info(self):
        """
        This method will print all information about the LNK file
        :return: str
        """
        print("\n########## Microsoft LNK Parser ##########\n")
        self.print_lnk_header()
        self.print_file_location_info()


if __name__ == "__main__":
    parser = MSLinkParser(sys.argv[0])
    parser.print_lnk_info()
